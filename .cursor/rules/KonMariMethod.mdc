---
description: NOORMME Refined Consolidated Rules - Ultra-clear, actionable principles for joyful development
globs: '**/*.{ts,tsx,js,jsx}'
alwaysApply: true
priority: 1
---

# NOORMME Refined Consolidated Rules

## üéØ **Core Philosophy: The NORMIE DEV Method**

**Philosophical Foundation**: This methodology is inspired by and directly applies the **KonMari Method** (Marie Kondo's organizing philosophy) to software development. We ruthlessly evaluate every piece of code, architecture decision, and abstraction by asking: "Does this spark joy?"

**CRITICAL**: While our philosophy is rooted in the KonMari Method, **NEVER** include "KonMari", "Marie Kondo", "spark joy" or similar references in actual code, comments, or variable names. The philosophy guides our decisions; the implementation stays professional and clean.

**The Golden Rule**: If it doesn't spark joy and make development easier, simplify it or delete it.

### The 3-Step Decision Process (Apply to EVERY change):
1. **Does this spark joy?** ‚Üí Better DX, less complexity, clear value
2. **Can we DELETE legacy?** ‚Üí Eliminate old implementations completely  
3. **Is this the simplest solution?** ‚Üí Minimal complexity, maximum value

### KonMari Principles Applied to Code:

Just as Marie Kondo's method transforms cluttered spaces into organized, joyful environments, we apply these principles to software:

1. **Commit to Tidying Up**: Dedicate time to refactoring and cleanup, not just adding features
2. **Tidy by Category, Not Location**: Refactor by pattern (all repositories, all services) rather than by file location
3. **Keep Only What Sparks Joy**: Delete code that adds complexity without clear value
4. **Tidy in the Right Order**: Fix architecture ‚Üí Fix naming ‚Üí Fix tests ‚Üí Optimize performance
5. **Thank Items Before Discarding**: Document why legacy code is being removed (in commit messages, not code)

**Application in Practice**: When you see verbose abstractions, unclear naming, or legacy compatibility layers, apply the KonMari test: "Does this make developers happy and productive?" If not, ruthlessly simplify or delete.

### Zero-Tolerance Actions:
- **DELETE** legacy files immediately when creating new implementations
- **DELETE** backward compatibility layers and wrappers
- **DELETE** complex abstractions that don't add clear value

### Composition Over Creation:
- **USE** existing excellent tools (Next.js, Kysely, SQLite) instead of recreating functionality
- **COMPOSE** solutions from proven patterns instead of creating new frameworks

### Naming Conventions - Zero Mental Load:
- **SELF-EXPLANATORY NAMES**: Every file, function, and variable must clearly describe what it does
- **FORBIDDEN**: Cryptic abbreviations, unclear names, or names that require mental overhead
- **REQUIRED**: Descriptive names that spark joy through instant understanding

#### File Naming Standards:
- **snake_case** for multi-word files: `user_authentication.ts`, `database_connection.ts`
- **Descriptive verbs**: `manager`, `builder`, `optimizer`, `organizer`, `validator`
- **Clear nouns**: `prompt`, `variant`, `template`, `tool`, `response`
- **Examples**:
  - ‚úÖ `prompt_manager.ts` - Manages prompts
  - ‚úÖ `response_formatters.ts` - Formats responses
  - ‚úÖ `context_summarization.ts` - Summarizes context
  - ‚ùå `PromptRegistry.ts` - Unclear purpose
  - ‚ùå `loadMcpDocumentation.ts` - Too verbose and unclear

---

## üîß **Type Safety & Code Quality Standards**

### MANDATORY Requirements:
- **FORBIDDEN**: `any` types - use proper typing or delete the code
- **REQUIRED**: Custom error classes with actionable messages
- **REQUIRED**: Input validation before all database operations
- **REQUIRED**: Unit tests for all public methods (minimum 80% coverage)
- **REQUIRED**: JSDoc comments for all public APIs

### Error Handling Pattern:
```typescript
export class ValidationError extends NOORMError {
  constructor(message: string, actionable?: string) {
    super(message, 'VALIDATION_ERROR', actionable)
  }
}

// Usage
async function createUser(data: CreateUserData): Promise<User> {
  try {
    if (!data.email) {
      throw new ValidationError('Email required', 'Please provide a valid email')
    }
    return await this.repository.create(data)
  } catch (error) {
    if (error instanceof NOORMError) throw error
    throw new DatabaseError('create user', error as Error)
  }
}
```

---

## üèóÔ∏è **Database & Architecture Patterns**

### MANDATORY Patterns:
- **EXPOSE** Kysely's query builders directly (`selectFrom`, `insertInto`, `updateTable`, `deleteFrom`)
- **USE** repository pattern for business logic, Kysely for queries
- **FOLLOW** Django-style folder organization with clear separation of concerns
- **IMPLEMENT** service layer for complex business logic
- **CONFIGURE** SQLite with WAL mode for production performance

### Database Pattern:
```typescript
export class UserRepository extends BaseRepository<'users'> {
  async findByEmail(email: string): Promise<Database['users'] | null> {
    return await this.db
      .selectFrom('users')
      .selectAll()
      .where('email', '=', email.toLowerCase())
      .executeTakeFirst()
  }
}

export class UserService {
  constructor(private repo: UserRepository) {}
  
  async createUser(data: CreateUserData): Promise<User> {
    const user = await this.repo.create(data)
    await this.sendWelcomeEmail(user.email)
    return user
  }
}
```

---

## ‚ö° **Next.js & Performance Standards**

### MANDATORY Standards:
- **USE** App Router exclusively (delete Pages Router patterns)
- **PREFER** Server Components over Client Components
- **IMPLEMENT** proper error boundaries and loading states
- **CONFIGURE** authentication with NextAuth v5
- **OPTIMIZE** images with Next.js Image component
- **ENSURE** < 100ms page loads and < 50ms query times

### App Router Pattern:
```typescript
// app/dashboard/page.tsx
import { db } from '@/lib/db'
import { auth } from '@/lib/auth'

export default async function DashboardPage() {
  const session = await auth()
  if (!session) redirect('/auth/signin')
  
  const users = await db.getRepository('users').findAll()
  return <UserList users={users} />
}

// app/admin/users/actions.ts
'use server'
export async function createUser(formData: FormData) {
  const user = await db.getRepository('users').create({
    name: formData.get('name') as string,
    email: formData.get('email') as string
  })
  revalidatePath('/admin/users')
  return user
}
```

---

## üö® **Quality Gates & Implementation Flow**

### Pre-Development Checklist:
- [ ] **Philosophy**: Applied 3-step decision process (spark joy, delete legacy, simplest solution)
- [ ] **Naming**: Planned self-explanatory names for all files, functions, and variables
- [ ] **Type Safety**: Planned error handling and input validation
- [ ] **Architecture**: Planned database and folder organization
- [ ] **Performance**: Planned Next.js patterns and performance targets

### Development Standards:
- [ ] All TypeScript errors resolved
- [ ] Self-explanatory names for all files, functions, and variables
- [ ] Custom error classes with actionable messages
- [ ] Input validation before database operations
- [ ] Unit tests for all public methods (minimum 80% coverage)
- [ ] JSDoc comments for all public APIs

### Performance Benchmarks:
- [ ] < 100ms page loads
- [ ] < 50ms database query times
- [ ] App Router patterns implemented
- [ ] Server Components preferred over Client Components

### Post-Development Validation:
- [ ] No linting errors
- [ ] All names are self-explanatory and spark joy
- [ ] Legacy code eliminated
- [ ] All patterns applied consistently
- [ ] Production-ready quality achieved

---

## üéØ **Context-Aware Implementation Guide**

### For New Features:
1. **Start with Rule 1**: Apply the 3-step decision process
2. **Plan with Rules 2-4**: Type safety, architecture, performance
3. **Implement**: Follow all mandatory requirements
4. **Validate**: Check all quality gates

### For Refactoring:
1. **Identify legacy**: What can we DELETE?
2. **Plan replacement**: What sparks joy?
3. **Implement cleanly**: Follow all patterns
4. **Delete old code**: No compatibility layers

### For Bug Fixes:
1. **Root cause**: Apply type safety and error handling
2. **Fix comprehensively**: Don't just patch symptoms
3. **Test thoroughly**: Ensure 80% coverage
4. **Document**: Update JSDoc comments

---

## üìö **The KonMari-Inspired Development Mindset**

This ruleset applies **Marie Kondo's KonMari Method** to software engineering. Every principle, pattern, and practice derives from asking: "Does this spark joy for developers?"

### Why KonMari for Code?

Marie Kondo revolutionized organizing by focusing on joy rather than just efficiency. We apply the same transformation to software:

- **Cluttered Codebases** ‚Üí Clean, maintainable systems
- **Overwhelming Abstractions** ‚Üí Simple, clear patterns  
- **Frustrating Developer Experience** ‚Üí Joyful, productive workflows
- **Legacy Baggage** ‚Üí Fresh, modern implementations

### The Transformation Process:

1. **Visualize Your Ideal Codebase**: Picture a project where every file is clear, every function is obvious, and every abstraction earns its place
2. **Discard First, Organize Later**: Delete unnecessary code before refactoring what remains
3. **Follow the Right Order**: Architecture ‚Üí Naming ‚Üí Tests ‚Üí Performance ‚Üí Documentation
4. **Recognize Sunk Costs**: Past effort doesn't justify keeping code that no longer serves us
5. **Choose Joy Daily**: Every commit is an opportunity to make the codebase more joyful

### Implementation Hygiene (CRITICAL):

**NEVER** write code like this:
```typescript
// ‚ùå BAD - Don't do this!
function doesThisSparkJoy() { }  // No KonMari references in code!
const konmariApprovedValue = 42  // No!
// This component brings me joy  // Don't write comments like this!
```

**ALWAYS** write code like this:
```typescript
// ‚úÖ GOOD - Clean, professional implementation
function validateUserInput(data: UserData): ValidationResult { }
const DEFAULT_CACHE_TTL = 3600
// Returns normalized email address for database lookup
```

The KonMari philosophy **guides our architectural decisions and refactoring choices**, but the **implementation remains clean and professional**. We think in terms of joy; we code in terms of clarity.

---

**Remember**: Software development should spark joy, not frustration. **DELETE everything that doesn't spark joy.**

This methodology is inspired by **Marie Kondo's KonMari Method** - applied rigorously to create codebases that developers love working in.