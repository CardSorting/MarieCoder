---
description: NOORMME Development Standards - Compassionate, intentional software development inspired by KonMari
globs: '**/*.{ts,tsx,js,jsx}'
alwaysApply: true
priority: 1
---

# NOORMME Development Standards

> *Guidance, not gospel. Pause, reflect, and choose with intention. Continuous evolution over perfection.*

---

## üéØ Core Philosophy

**Inspired by KonMari Method**: We approach code with Marie Kondo's mindfulness‚Äîhonoring what served us, learning from it, and evolving with gratitude. Philosophy guides our thinking; clarity guides our code.

**CRITICAL**: Never use "KonMari", "spark joy", or philosophical terms in code (variables, functions, comments). Keep philosophy in your heart and commit messages only.

### Before Any Change - Three Questions:

1. **What purpose did this serve?** (Observe with curiosity)
2. **What has this taught us?** (Learn with gratitude)  
3. **What brings clarity now?** (Choose with intention)

### Six-Step Evolution Process:

When code has completed its purpose:

1. **OBSERVE** - Understand why it exists and what it taught us
2. **APPRECIATE** - Honor the problems it solved
3. **LEARN** - Extract wisdom from patterns and friction
4. **EVOLVE** - Build clearer implementations with those lessons
5. **RELEASE** - Let go of old code once new path is stable
6. **SHARE** - Document lessons in commit messages

**Example Commit Message**:
```
feat: Migrate to NextAuth v5

Previous custom auth taught us session invalidation 
and OAuth edge cases. Evolving to battle-tested solution.

Lessons applied:
- Robust session management required
- OAuth needs comprehensive error handling
- Security updates must be timely
```

---

## üìù Naming Standards (Non-Negotiable)

### Files - MUST use snake_case:
```
‚úÖ prompt_manager.ts
‚úÖ response_formatters.ts
‚úÖ context_summarization.ts
‚ùå PromptRegistry.ts (wrong case)
‚ùå loadMcpDocumentation.ts (camelCase)
```

**Use descriptive verbs**: `manager`, `builder`, `optimizer`, `organizer`, `validator`  
**Use clear nouns**: `prompt`, `variant`, `template`, `tool`, `response`

### Variables & Functions:
- **MUST be self-explanatory** without comments
- **NO abbreviations** (except: `id`, `url`, `api`)
- **Indicate type/purpose**: `getUserById()`, `isValidEmail()`, `userCount`

---

## üîß Type Safety & Quality (Required)

### Non-Negotiable Rules:

‚úÖ **DO**:
- Use specific types (never `any` without explicit justification)
- Validate ALL inputs before database operations
- Write tests for public methods (target 80%+ coverage)
- Add JSDoc to all public APIs
- Create actionable error messages with fix guidance

‚ùå **DON'T**:
- Use `any` type casually
- Skip input validation
- Leave public APIs undocumented
- Write vague error messages

### Error Handling Pattern (Required):

```typescript
export class ValidationError extends NOORMError {
  constructor(message: string, actionable?: string) {
    super(message, 'VALIDATION_ERROR', actionable)
  }
}

// Usage - ALWAYS include actionable guidance
async function createUser(data: CreateUserData): Promise<User> {
  try {
    if (!data.email) {
      throw new ValidationError(
        'Email required', 
        'Please provide a valid email address'
      )
    }
    return await this.repository.create(data)
  } catch (error) {
    if (error instanceof NOORMError) throw error
    throw new DatabaseError('create user', error as Error)
  }
}
```

---

## üèóÔ∏è Architecture Standards

### Required Patterns:

**Repository Pattern** - Separate data access from business logic:
```typescript
export class UserRepository extends BaseRepository<'users'> {
  async findByEmail(email: string): Promise<Database['users'] | null> {
    return await this.db
      .selectFrom('users')
      .selectAll()
      .where('email', '=', email.toLowerCase())
      .executeTakeFirst()
  }
}
```

**Service Layer** - Only when business logic gets complex:
```typescript
export class UserService {
  constructor(private repo: UserRepository) {}
  
  async createUser(data: CreateUserData): Promise<User> {
    const user = await this.repo.create(data)
    await this.sendWelcomeEmail(user.email)
    return user
  }
}
```

### Database Requirements:

- **MUST** expose Kysely query builders directly (`selectFrom`, `insertInto`, `updateTable`, `deleteFrom`)
- **MUST** follow Django-style structure (organize by feature/domain, not type)
- **MUST** enable SQLite WAL mode for performance
- **PREFER** composition over creation (use proven libraries)

---

## ‚ö° Next.js Standards (Required)

### Non-Negotiable:

- **MUST use App Router** (not Pages Router)
- **MUST default to Server Components** (Client Components only when needed)
- **MUST implement error.tsx** for error boundaries
- **MUST implement loading.tsx** for async operations
- **MUST use NextAuth v5** for authentication
- **MUST use Next.js Image** component for all images

### Performance Targets:

- Page loads: **<100ms**
- Database queries: **<50ms**

### App Router Pattern (Required):

```typescript
// app/dashboard/page.tsx - Server Component by default
import { db } from '@/lib/db'
import { auth } from '@/lib/auth'

export default async function DashboardPage() {
  const session = await auth()
  if (!session) redirect('/auth/signin')
  
  const users = await db.getRepository('users').findAll()
  return <UserList users={users} />
}

// app/admin/users/actions.ts - Server Actions
'use server'
export async function createUser(formData: FormData) {
  const user = await db.getRepository('users').create({
    name: formData.get('name') as string,
    email: formData.get('email') as string
  })
  revalidatePath('/admin/users')
  return user
}
```

---

## ‚úÖ Quality Checklist

### Before Starting:
- [ ] Understand existing code and patterns
- [ ] Plan clear, descriptive names
- [ ] Design error handling with actionable messages
- [ ] Consider architecture (repositories, services)
- [ ] Identify performance requirements

### During Development:
- [ ] Strict TypeScript (no casual `any`)
- [ ] Self-documenting names
- [ ] Actionable error messages
- [ ] Validate all inputs
- [ ] Write tests (80%+ target)
- [ ] JSDoc on public APIs

### Performance:
- [ ] Page loads <100ms
- [ ] DB queries <50ms
- [ ] App Router patterns
- [ ] Server Components default

### Before Completing:
- [ ] All linter errors resolved
- [ ] Names immediately clear
- [ ] Changes documented in commit
- [ ] Patterns applied system-wide
- [ ] Tests passing

---

## üéØ Implementation Workflows

### New Features:
1. **Reflect** ‚Üí Study existing patterns
2. **Plan** ‚Üí Design with type safety and performance
3. **Implement** ‚Üí Build with clear names and validation
4. **Test** ‚Üí Cover public APIs (80%+ target)
5. **Document** ‚Üí JSDoc and commit messages with context

### Refactoring:
1. **Observe** ‚Üí What patterns completed their purpose?
2. **Learn** ‚Üí What lessons does this offer?
3. **Envision** ‚Üí What would serve better?
4. **Evolve** ‚Üí Implement new pattern
5. **Release** ‚Üí Remove old code once stable
6. **Document** ‚Üí Share lessons learned

### Bug Fixes:
1. **Understand** ‚Üí Find root cause, not just symptom
2. **Fix** ‚Üí Address underlying issue
3. **Test** ‚Üí Prevent regression
4. **Document** ‚Üí Share discovery
5. **Strengthen** ‚Üí Add type safety/validation to prevent recurrence

---

## üôè Mindset

**Before each session**, remember:

*"I honor the code before me. I learn from every pattern. 'Legacy' was once innovative. I refactor not as criticism, but evolution. I write for clarity. I release with gratitude. I document what we learned. Every commit cares for future developers."*

### The Path:

- **Honor existing work** ‚Üí Learn from it before changing it
- **Compose over create** ‚Üí Use proven tools (Next.js, Kysely, SQLite)
- **Simplify with compassion** ‚Üí Evolution, not demolition
- **System-wide changes** ‚Üí Address patterns everywhere, not piecemeal
- **Natural order** ‚Üí Architecture ‚Üí Naming ‚Üí Tests ‚Üí Performance ‚Üí Documentation

### Remember:

This isn't about perfection or ruthlessness‚Äîit's about **intentional, compassionate improvement**.

- We **release** code because we learned better ways (not because we hate it)
- We **evolve** to honor lessons (not to criticize past decisions)
- We **practice** clarity habits (not enforce rigid rules)

**Be gentle with yourself. Be gentle with the code. Be gentle with those who came before.**

Each small act of care compounds into a codebase that brings clarity and ease.

---

*Philosophy guides thinking. Clarity guides implementation. Compassion guides evolution.*