---
description: Database patterns and Kysely integration for NOORMME
globs: '**/*.{ts,tsx}'
alwaysApply: true
priority: 3
---

# NOORMME Database Guidelines

## üéØ **Core Philosophy**

### "Leverage Kysely Fully"
**CRITICAL**: Don't recreate query building - use Kysely's native capabilities:
- ‚úÖ **Direct Access** - Expose Kysely's query builders directly
- ‚úÖ **Type Safety** - Use Kysely's generics and type inference
- ‚úÖ **Native Methods** - Use `selectFrom()`, `insertInto()`, `updateTable()`, `deleteFrom()`
- ‚ùå **Custom Wrappers** - Don't wrap Kysely's core functionality
- ‚ùå **Recreating Logic** - Don't rebuild what Kysely already provides

## üèóÔ∏è **Database Connection Pattern**

### ‚úÖ CORRECT - Direct Kysely Integration
```typescript
import { Kysely } from 'kysely'
import { Database } from '@/types/database'

export class DatabaseConnection {
  private db: Kysely<Database>
  
  constructor() {
    this.db = new Kysely<Database>({
      dialect: 'sqlite',
      database: './app.db'
    })
  }
  
  getKysely(): Kysely<Database> {
    return this.db
  }
  
  // Expose Kysely's query builders directly
  selectFrom<T extends keyof Database>(table: T) {
    return this.db.selectFrom(table)
  }
  
  insertInto<T extends keyof Database>(table: T) {
    return this.db.insertInto(table)
  }
  
  updateTable<T extends keyof Database>(table: T) {
    return this.db.updateTable(table)
  }
  
  deleteFrom<T extends keyof Database>(table: T) {
    return this.db.deleteFrom(table)
  }
}
```

### ‚ùå WRONG - Wrapping Kysely
```typescript
// DON'T DO THIS - Wrapping Kysely's functionality
export class DatabaseConnection {
  private db: Kysely<Database>
  
  // DON'T - Creating custom query methods
  async customSelect(table: string, where: any) {
    return this.db.selectFrom(table).where(where).execute()
  }
  
  // DON'T - Recreating Kysely's query building
  buildQuery(table: string, conditions: any) {
    let query = this.db.selectFrom(table)
    // Custom query building logic...
    return query
  }
}
```

## üìä **Repository Pattern with Kysely**

### ‚úÖ CORRECT - Leveraging Kysely Fully
```typescript
export abstract class BaseRepository<T extends keyof Database> {
  protected tableName: T
  protected db: Kysely<Database>
  protected queryBuilder: QueryBuilderFactory | null

  constructor(tableName: T, db: Kysely<Database>, options: RepositoryOptions = {}) {
    this.tableName = tableName
    this.db = db
    this.queryBuilder = null // Set by database instance
  }

  // ‚úÖ CORRECT - Direct Kysely usage with proper error handling
  async findById(id: string): Promise<Database[T] | null> {
    try {
      if (!id || typeof id !== "string" || id.trim() === "") {
        throw new ValidationError("Valid ID is required", "Please provide a valid record ID")
      }

      let query = this.db
        .selectFrom(this.tableName)
        .selectAll()
        .where("id" as any, "=", id)

      // Apply soft delete filter if enabled
      if (this.options.enableSoftDelete) {
        query = query.where("status" as any, "!=", "deleted")
      }

      const result = await query.executeTakeFirst()
      return (result as unknown as Database[T]) || null
    } catch (error) {
      if (error instanceof NOORMError) {
        throw error
      }
      throw new NOORMError(
        `Failed to find ${String(this.tableName)} by ID: ${error instanceof Error ? error.message : "Unknown error"}`,
        "FIND_BY_ID_ERROR",
        "Please check the ID and try again"
      )
    }
  }

  // ‚úÖ CORRECT - Transaction support with Kysely
  async create(data: Partial<Database[T]>): Promise<Database[T]> {
    try {
      await this.validateCreateData(data)

      const now = new Date()
      const createData = {
        ...data,
        id: data.id || this.generateId(),
        createdAt: now.toISOString(),
        updatedAt: now.toISOString(),
      }

      const result = await this.db
        .insertInto(this.tableName)
        .values(createData as any)
        .returningAll()
        .executeTakeFirst()

      if (!result) {
        throw new NOORMError(
          `Failed to create ${String(this.tableName)} record`,
          "CREATE_FAILED",
          "Please check your data and try again"
        )
      }

      // Audit log if enabled
      if (this.options.auditLog) {
        await this.logAudit("CREATE", (result as any).id, createData)
      }

      // Invalidate cache
      if (this.cache) {
        await this.invalidateRelatedCache()
      }

      return result as unknown as Database[T]
    } catch (error) {
      if (error instanceof NOORMError) {
        throw error
      }
      throw new NOORMError(
        `Failed to create ${String(this.tableName)}: ${error instanceof Error ? error.message : "Unknown error"}`,
        "CREATE_ERROR",
        "Please check your data and try again"
      )
    }
  }
}
```

## üîß **Query Builder Integration**

### ‚úÖ CORRECT - Exposing Kysely Directly
```typescript
export class QueryBuilder<T extends keyof Database, O = Database[T]> {
  private db: Kysely<Database>
  private table: T
  private cache?: QueryCache

  constructor(db: Kysely<Database>, table: T, cache?: QueryCache) {
    this.db = db
    this.table = table
    this.cache = cache
  }

  // ‚úÖ CORRECT - Direct access to Kysely's query builders
  selectFrom(): SelectQueryBuilder<Database, T, O> {
    return this.db.selectFrom(this.table) as SelectQueryBuilder<Database, T, O>
  }

  insertInto(): InsertQueryBuilder<Database, T, O> {
    return this.db.insertInto(this.table) as InsertQueryBuilder<Database, T, O>
  }

  updateTable(): UpdateQueryBuilder<Database, T, T, O> {
    return this.db.updateTable(this.table) as UpdateQueryBuilder<Database, T, T, O>
  }

  deleteFrom(): DeleteQueryBuilder<Database, T, O> {
    return this.db.deleteFrom(this.table) as DeleteQueryBuilder<Database, T, O>
  }

  // ‚úÖ CORRECT - Helper methods built on top of Kysely
  async findById(id: string): Promise<Database[T] | null> {
    try {
      if (!id || typeof id !== "string" || id.trim() === "") {
        throw new ValidationError("Valid ID is required", "Please provide a valid record ID")
      }

      // Check cache first
      if (this.cache) {
        const cacheKey = `findById:${id}`
        const cached = await this.cache.get(cacheKey)
        if (cached) {
          return cached as Database[T]
        }
      }

      const result = await this.db.selectFrom(this.table).selectAll().where("id" as any, "=", id).executeTakeFirst()

      // Cache result if found
      if (this.cache && result) {
        this.cache.set(cacheKey, result as unknown as Database[T])
      }

      return (result as unknown as Database[T]) || null
    } catch (error) {
      if (error instanceof NOORMError) {
        throw error
      }
      throw new NOORMError(
        `Failed to find ${String(this.table)} by ID: ${error instanceof Error ? error.message : "Unknown error"}`,
        "FIND_BY_ID_ERROR",
        "Please check the ID and try again"
      )
    }
  }
}
```

### ‚ùå WRONG - Recreating Query Building
```typescript
// DON'T DO THIS - Recreating Kysely's functionality
export class QueryBuilder<T extends keyof Database> {
  private db: Kysely<Database>
  private table: T

  // DON'T - Custom query building methods
  async customFind(conditions: any) {
    // Custom query building logic that Kysely already provides
    let query = this.db.selectFrom(this.table)
    
    if (conditions.where) {
      Object.entries(conditions.where).forEach(([key, value]) => {
        query = query.where(key as any, "=", value)
      })
    }
    
    return query.execute()
  }
  
  // DON'T - Wrapping Kysely's methods unnecessarily
  async wrappedSelect() {
    return this.db.selectFrom(this.table).selectAll().execute()
  }
}
```

## üîÑ **Migration Management with Kysely**

### ‚úÖ CORRECT - Using Kysely Transactions
```typescript
export class MigrationManager {
  private db: Kysely<Database>

  constructor(db: Kysely<Database>) {
    this.db = db
  }

  // ‚úÖ CORRECT - Using Kysely's transaction system
  async executeMigration(migration: Migration): Promise<MigrationResult> {
    const startTime = Date.now()

    try {
      if (!migration || !migration.version || !migration.name || !migration.up) {
        throw new ValidationError(
          "Valid migration object is required",
          "Please provide a migration with version, name, and up function"
        )
      }

      // Execute migration in transaction
      const result = await this.db.transaction().execute(async (trx) => {
        // Execute migration
        await migration.up(trx)

        // Record migration
        const executionTime = Date.now() - startTime
        const checksum = this.generateChecksum(migration)
        const now = new Date().toISOString()

        await trx.executeQuery({
          sql: `
            INSERT INTO schema_migrations 
            (id, version, name, description, execution_time_ms, checksum, executed_at, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `,
          parameters: [
            migration.id,
            migration.version,
            migration.name,
            migration.description,
            executionTime,
            checksum,
            now,
            now,
            now
          ]
        } as any)

        return { executionTime, checksum }
      })

      return {
        success: true,
        migration,
        executionTime: result.executionTime
      }
    } catch (error) {
      const executionTime = Date.now() - startTime
      return {
        success: false,
        migration,
        executionTime,
        error: error instanceof Error ? error.message : "Unknown error"
      }
    }
  }
}
```

## üéØ **Type Safety with Kysely**

### ‚úÖ CORRECT - Proper Type Assertions
```typescript
// ‚úÖ CORRECT - Use proper type assertions for Kysely's complex types
const result = await this.db
  .selectFrom(this.tableName)
  .selectAll()
  .where("id" as any, "=", id)
  .executeTakeFirst()

return (result as unknown as Database[T]) || null

// ‚úÖ CORRECT - For raw SQL queries
await this.db.executeQuery({
  sql: `SELECT * FROM users WHERE email = ?`,
  parameters: [email]
} as any)

// ‚úÖ CORRECT - For dynamic column references
query = query.where("status" as any, "!=", "deleted")
query = query.orderBy("createdAt" as any, "desc")
```

### ‚ùå WRONG - Incorrect Type Handling
```typescript
// DON'T DO THIS - Incorrect type assertions
const result = await this.db
  .selectFrom(this.tableName)
  .selectAll()
  .where("id", "=", id) // This will cause type errors
  .executeTakeFirst()

return result as Database[T] // This will cause type errors

// DON'T DO THIS - Using any without proper context
const result = await this.db
  .selectFrom(this.tableName)
  .selectAll()
  .executeTakeFirst()

return result as any // Too broad, loses type safety
```

## üö® **Error Handling Integration**

### ‚úÖ CORRECT - Comprehensive Error Handling
```typescript
// ‚úÖ CORRECT - Comprehensive error handling
try {
  const result = await this.db
    .selectFrom(this.tableName)
    .selectAll()
    .where("id" as any, "=", id)
    .executeTakeFirst()

  if (!result) {
    throw new NotFoundError(
      `${String(this.tableName)} record not found`,
      "Please check the ID and try again"
    )
  }

  return result as unknown as Database[T]
} catch (error) {
  if (error instanceof NOORMError) {
    throw error
  }
  throw new NOORMError(
    `Failed to find ${String(this.tableName)}: ${error instanceof Error ? error.message : "Unknown error"}`,
    "FIND_ERROR",
    "Please check your parameters and try again"
  )
}
```

## üíæ **Caching Integration**

### ‚úÖ CORRECT - Cache Integration with Kysely
```typescript
// ‚úÖ CORRECT - Cache integration with Kysely queries
async findById(id: string): Promise<Database[T] | null> {
  // Check cache first
  if (this.cache) {
    const cacheKey = `findById:${id}`
    const cached = await this.cache.get(cacheKey)
    if (cached) {
      return cached as Database[T]
    }
  }

  const result = await this.db
    .selectFrom(this.tableName)
    .selectAll()
    .where("id" as any, "=", id)
    .executeTakeFirst()

  // Cache result if found
  if (this.cache && result) {
    const cacheKey = `findById:${id}`
    await this.cache.set(cacheKey, result as unknown as Database[T])
  }

  return (result as unknown as Database[T]) || null
}
```

## üìä **SQLite Configuration**

### WAL Mode Setup
```sql
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
PRAGMA cache_size=-64000;
PRAGMA temp_store=MEMORY;
PRAGMA foreign_keys=ON;
```

### Performance Optimization
- Enable WAL mode for concurrent access
- Set optimal cache size (-64000 = 64MB)
- Use memory-based temporary storage
- Enable foreign key constraints

## üéØ **Best Practices**

### DO's ‚úÖ
- Use Kysely's query builders directly (`selectFrom`, `insertInto`, `updateTable`, `deleteFrom`)
- Leverage Kysely's transaction system for atomic operations
- Use proper type assertions (`as unknown as Database[T]`) for complex Kysely types
- Implement comprehensive error handling with NOORMError
- Use caching integration with QueryCache
- Apply input validation before database operations
- Use Kysely's type inference and generics
- Expose Kysely's native methods directly
- Build helper methods on top of Kysely, not instead of it

### DON'Ts ‚ùå
- Don't wrap Kysely's core query building functionality
- Don't recreate query building logic that Kysely already provides
- Don't use `any` types without proper type assertions
- Don't ignore error handling in database operations
- Don't bypass Kysely's transaction system for multi-step operations
- Don't use legacy database patterns or old query builders
- Don't mix different database access patterns in the same codebase
- Don't create custom query builders that duplicate Kysely's functionality
- Don't use overly broad type assertions that lose type safety

## üöÄ **Common Patterns**

### Direct Kysely Usage
```typescript
// ‚úÖ CORRECT - Direct Kysely usage
const users = await db
  .selectFrom('users')
  .selectAll()
  .where('status', '=', 'active')
  .orderBy('createdAt', 'desc')
  .limit(10)
  .execute()
```

### Repository with Kysely
```typescript
// ‚úÖ CORRECT - Repository leveraging Kysely
export class UserRepository extends BaseRepository<'users'> {
  async findByEmail(email: string): Promise<Database['users'] | null> {
    return await this.findOneBy({ email: email.toLowerCase() })
  }
  
  async findActiveUsers(limit: number = 100): Promise<Database['users'][]> {
    return await this.findBy({ status: 'active' }, { 
      limit, 
      orderBy: 'createdAt', 
      orderDirection: 'desc' 
    })
  }
}
```

### Query Builder Factory
```typescript
// ‚úÖ CORRECT - Query builder factory
export class QueryBuilderFactory {
  private db: Kysely<Database>
  private cacheManager: CacheManager

  constructor(db: Kysely<Database>, cacheManager: CacheManager) {
    this.db = db
    this.cacheManager = cacheManager
  }

  create<T extends keyof Database>(table: T): QueryBuilder<T> {
    return new QueryBuilder(this.db, table, this.cacheManager.getCache(String(table)))
  }
}
```

This guide ensures developers understand how to properly integrate with Kysely while maintaining type safety, error handling, and performance optimization.