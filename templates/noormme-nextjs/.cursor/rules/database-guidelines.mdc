# NOORMME Database Guidelines

## Kysely Integration Strategy

### Core Philosophy
**LEVERAGE KYSELY FULLY** - Don't recreate query building, use Kysely's native capabilities:
- ✅ **Direct Kysely Access** - Expose Kysely's query builders directly
- ✅ **Type Safety** - Use Kysely's generics and type inference
- ✅ **Native Methods** - Use `selectFrom()`, `insertInto()`, `updateTable()`, `deleteFrom()`
- ❌ **Custom Wrappers** - Don't wrap Kysely's core functionality
- ❌ **Recreating Logic** - Don't rebuild what Kysely already provides

## SQLite Configuration

### WAL Mode Setup
```sql
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
PRAGMA cache_size=-64000;
PRAGMA temp_store=MEMORY;
PRAGMA foreign_keys=ON;
```

### Performance Optimization
- Enable WAL mode for concurrent access
- Set optimal cache size (-64000 = 64MB)
- Use memory-based temporary storage
- Enable foreign key constraints

## Repository Pattern with Kysely

### Base Repository - Leveraging Kysely Fully
```typescript
export abstract class BaseRepository<T extends keyof Database> {
  protected tableName: T
  protected db: Kysely<Database>
  protected queryBuilder: QueryBuilderFactory | null

  constructor(tableName: T, db: Kysely<Database>, options: RepositoryOptions = {}) {
    this.tableName = tableName
    this.db = db
    this.queryBuilder = null // Set by database instance
  }

  // ✅ CORRECT - Direct Kysely usage with proper error handling
  async findById(id: string): Promise<Database[T] | null> {
    try {
      if (!id || typeof id !== "string" || id.trim() === "") {
        throw new ValidationError("Valid ID is required", "Please provide a valid record ID")
      }

      let query = this.db
        .selectFrom(this.tableName)
        .selectAll()
        .where("id" as any, "=", id)

      // Apply soft delete filter if enabled
      if (this.options.enableSoftDelete) {
        query = query.where("status" as any, "!=", "deleted")
      }

      const result = await query.executeTakeFirst()
      return (result as unknown as Database[T]) || null
    } catch (error) {
      if (error instanceof NOORMError) {
        throw error
      }
      throw new NOORMError(
        `Failed to find ${String(this.tableName)} by ID: ${error instanceof Error ? error.message : "Unknown error"}`,
        "FIND_BY_ID_ERROR",
        "Please check the ID and try again"
      )
    }
  }

  // ✅ CORRECT - Transaction support with Kysely
  async create(data: Partial<Database[T]>): Promise<Database[T]> {
    try {
      await this.validateCreateData(data)

      const now = new Date()
      const createData = {
        ...data,
        id: data.id || this.generateId(),
        createdAt: now.toISOString(),
        updatedAt: now.toISOString(),
      }

      const result = await this.db
        .insertInto(this.tableName)
        .values(createData as any)
        .returningAll()
        .executeTakeFirst()

      if (!result) {
        throw new NOORMError(
          `Failed to create ${String(this.tableName)} record`,
          "CREATE_FAILED",
          "Please check your data and try again"
        )
      }

      // Audit log if enabled
      if (this.options.auditLog) {
        await this.logAudit("CREATE", (result as any).id, createData)
      }

      // Invalidate cache
      if (this.cache) {
        await this.invalidateRelatedCache()
      }

      return result as unknown as Database[T]
    } catch (error) {
      if (error instanceof NOORMError) {
        throw error
      }
      throw new NOORMError(
        `Failed to create ${String(this.tableName)}: ${error instanceof Error ? error.message : "Unknown error"}`,
        "CREATE_ERROR",
        "Please check your data and try again"
      )
    }
  }
}
```

### Dynamic Finders with Kysely
```typescript
// ✅ CORRECT - Using Kysely's query building
const userRepo = db.getRepository('users')
const user = await userRepo.findByEmail('john@example.com')
const activeUsers = await userRepo.findBy({ status: 'active' }, { 
  limit: 100, 
  orderBy: 'createdAt', 
  orderDirection: 'desc' 
})
```

## Query Builder Integration

### QueryBuilder Pattern - Exposing Kysely Directly
```typescript
export class QueryBuilder<T extends keyof Database, O = Database[T]> {
  private db: Kysely<Database>
  private table: T
  private cache?: QueryCache

  constructor(db: Kysely<Database>, table: T, cache?: QueryCache) {
    this.db = db
    this.table = table
    this.cache = cache
  }

  // ✅ CORRECT - Direct access to Kysely's query builders
  selectFrom(): SelectQueryBuilder<Database, T, O> {
    return this.db.selectFrom(this.table) as SelectQueryBuilder<Database, T, O>
  }

  insertInto(): InsertQueryBuilder<Database, T, O> {
    return this.db.insertInto(this.table) as InsertQueryBuilder<Database, T, O>
  }

  updateTable(): UpdateQueryBuilder<Database, T, T, O> {
    return this.db.updateTable(this.table) as UpdateQueryBuilder<Database, T, T, O>
  }

  deleteFrom(): DeleteQueryBuilder<Database, T, O> {
    return this.db.deleteFrom(this.table) as DeleteQueryBuilder<Database, T, O>
  }

  // ✅ CORRECT - Helper methods built on top of Kysely
  async findById(id: string): Promise<Database[T] | null> {
    try {
      if (!id || typeof id !== "string" || id.trim() === "") {
        throw new ValidationError("Valid ID is required", "Please provide a valid record ID")
      }

      // Check cache first
      if (this.cache) {
        const cacheKey = `findById:${id}`
        const cached = await this.cache.get(cacheKey)
        if (cached) {
          return cached as Database[T]
        }
      }

      const result = await this.db.selectFrom(this.table).selectAll().where("id" as any, "=", id).executeTakeFirst()

      // Cache result if found
      if (this.cache && result) {
        this.cache.set(cacheKey, result as unknown as Database[T])
      }

      return (result as unknown as Database[T]) || null
    } catch (error) {
      if (error instanceof NOORMError) {
        throw error
      }
      throw new NOORMError(
        `Failed to find ${String(this.table)} by ID: ${error instanceof Error ? error.message : "Unknown error"}`,
        "FIND_BY_ID_ERROR",
        "Please check the ID and try again"
      )
    }
  }
}
```

## Migration Management with Kysely

### Migration Pattern - Using Kysely Transactions
```typescript
export class MigrationManager {
  private db: Kysely<Database>

  constructor(db: Kysely<Database>) {
    this.db = db
  }

  // ✅ CORRECT - Using Kysely's transaction system
  async executeMigration(migration: Migration): Promise<MigrationResult> {
    const startTime = Date.now()

    try {
      if (!migration || !migration.version || !migration.name || !migration.up) {
        throw new ValidationError(
          "Valid migration object is required",
          "Please provide a migration with version, name, and up function"
        )
      }

      // Execute migration in transaction
      const result = await this.db.transaction().execute(async (trx) => {
        // Execute migration
        await migration.up(trx)

        // Record migration
        const executionTime = Date.now() - startTime
        const checksum = this.generateChecksum(migration)
        const now = new Date().toISOString()

        await trx.executeQuery({
          sql: `
            INSERT INTO schema_migrations 
            (id, version, name, description, execution_time_ms, checksum, executed_at, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
          `,
          parameters: [
            migration.id,
            migration.version,
            migration.name,
            migration.description,
            executionTime,
            checksum,
            now,
            now,
            now
          ]
        } as any)

        return { executionTime, checksum }
      })

      return {
        success: true,
        migration,
        executionTime: result.executionTime
      }
    } catch (error) {
      const executionTime = Date.now() - startTime
      return {
        success: false,
        migration,
        executionTime,
        error: error instanceof Error ? error.message : "Unknown error"
      }
    }
  }
}
```

## Type Safety with Kysely

### Proper Type Assertions
```typescript
// ✅ CORRECT - Use proper type assertions for Kysely's complex types
const result = await this.db
  .selectFrom(this.tableName)
  .selectAll()
  .where("id" as any, "=", id)
  .executeTakeFirst()

return (result as unknown as Database[T]) || null

// ✅ CORRECT - For raw SQL queries
await this.db.executeQuery({
  sql: `SELECT * FROM users WHERE email = ?`,
  parameters: [email]
} as any)

// ✅ CORRECT - For dynamic column references
query = query.where("status" as any, "!=", "deleted")
query = query.orderBy("createdAt" as any, "desc")
```

## Error Handling Integration

### NOORMError Integration
```typescript
// ✅ CORRECT - Comprehensive error handling
try {
  const result = await this.db
    .selectFrom(this.tableName)
    .selectAll()
    .where("id" as any, "=", id)
    .executeTakeFirst()

  if (!result) {
    throw new NotFoundError(
      `${String(this.tableName)} record not found`,
      "Please check the ID and try again"
    )
  }

  return result as unknown as Database[T]
} catch (error) {
  if (error instanceof NOORMError) {
    throw error
  }
  throw new NOORMError(
    `Failed to find ${String(this.tableName)}: ${error instanceof Error ? error.message : "Unknown error"}`,
    "FIND_ERROR",
    "Please check your parameters and try again"
  )
}
```

## Caching Integration

### QueryCache with Kysely
```typescript
// ✅ CORRECT - Cache integration with Kysely queries
async findById(id: string): Promise<Database[T] | null> {
  // Check cache first
  if (this.cache) {
    const cacheKey = `findById:${id}`
    const cached = await this.cache.get(cacheKey)
    if (cached) {
      return cached as Database[T]
    }
  }

  const result = await this.db
    .selectFrom(this.tableName)
    .selectAll()
    .where("id" as any, "=", id)
    .executeTakeFirst()

  // Cache result if found
  if (this.cache && result) {
    const cacheKey = `findById:${id}`
    await this.cache.set(cacheKey, result as unknown as Database[T])
  }

  return (result as unknown as Database[T]) || null
}
```

## Query Optimization

### Index Recommendations
- Analyze query patterns automatically
- Recommend indexes for frequently queried columns
- Create indexes for foreign keys
- Monitor query performance

### Caching Strategy
- Cache frequently accessed data
- Use intelligent cache invalidation
- Monitor cache hit rates
- Implement cache warming

## Migration Management

### Migration Generation
```typescript
export class MigrationGenerator {
  async generateMigration(
    databasePath: string,
    name: string
  ): Promise<MigrationFile> {
    // Detect schema changes
    const changes = await this.detectSchemaChanges(databasePath)
    
    // Generate migration file
    return this.createMigrationFile(name, changes)
  }
}
```

### Migration Validation
- Validate migration syntax
- Check for breaking changes
- **FORBIDDEN**: Rollback compatibility - clean breaks only
- Test migrations in development

## Legacy Database Elimination
- **MANDATORY**: Delete old database services when creating unified ones
- **FORBIDDEN**: Multiple database connection patterns
- **REQUIRED**: Use unified database service architecture only
- **PROHIBITED**: Legacy repository patterns or old query builders
- **CRITICAL**: Always leverage Kysely's native capabilities instead of recreating them

## Developer Guidelines

### DO's ✅
- Use Kysely's query builders directly (`selectFrom`, `insertInto`, `updateTable`, `deleteFrom`)
- Leverage Kysely's transaction system for atomic operations
- Use proper type assertions (`as unknown as Database[T]`) for complex Kysely types
- Implement comprehensive error handling with NOORMError
- Use caching integration with QueryCache
- Apply input validation before database operations
- Use Kysely's type inference and generics

### DON'Ts ❌
- Don't wrap Kysely's core query building functionality
- Don't recreate query building logic that Kysely already provides
- Don't use `any` types without proper type assertions
- Don't ignore error handling in database operations
- Don't bypass Kysely's transaction system for multi-step operations
- Don't use legacy database patterns or old query builders
- Don't mix different database access patterns in the same codebase