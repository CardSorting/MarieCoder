---
description: Quality standards, testing, and validation guidelines for NOORMME
globs: '**/*.{ts,tsx,js,jsx,test.ts,test.tsx,spec.ts,spec.tsx}'
alwaysApply: true
priority: 6
---

# NOORMME Quality Standards

## ðŸŽ¯ **Core Philosophy**

### Quality First
**CRITICAL**: All code must meet the highest quality standards. If it doesn't spark joy through quality, delete it and rewrite it properly.

## ðŸ§ª **Testing Standards**

### Test Structure and Organization
```
src/
â”œâ”€â”€ __tests__/              # Test utilities and setup
â”‚   â”œâ”€â”€ setup.ts            # Test configuration
â”‚   â”œâ”€â”€ mocks/              # Mock implementations
â”‚   â””â”€â”€ fixtures/           # Test data fixtures
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Button.tsx
â”‚   â””â”€â”€ Button.test.tsx     # Component tests
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ UserService.ts
â”‚   â”‚   â””â”€â”€ UserService.test.ts  # Service tests
â”‚   â””â”€â”€ repositories/
â”‚       â”œâ”€â”€ UserRepository.ts
â”‚       â””â”€â”€ UserRepository.test.ts  # Repository tests
â””â”€â”€ app/
    â”œâ”€â”€ api/
    â”‚   â””â”€â”€ users/
    â”‚       â”œâ”€â”€ route.ts
    â”‚       â””â”€â”€ route.test.ts      # API tests
```

### Test Categories
1. **Unit Tests** - Test individual functions and components
2. **Integration Tests** - Test service and repository interactions
3. **API Tests** - Test API endpoints and responses
4. **E2E Tests** - Test complete user workflows
5. **Visual Tests** - Test component rendering and styling

## ðŸ”§ **Testing Setup**

### Jest Configuration
```typescript
// jest.config.js
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testEnvironment: 'jest-environment-jsdom',
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
    '!src/**/*.test.{ts,tsx}',
    '!src/**/*.spec.{ts,tsx}',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
}

module.exports = createJestConfig(customJestConfig)
```

### Test Setup File
```typescript
// src/__tests__/setup.ts
import '@testing-library/jest-dom'
import { TextEncoder, TextDecoder } from 'util'

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      prefetch: jest.fn(),
      back: jest.fn(),
      forward: jest.fn(),
      refresh: jest.fn(),
    }
  },
  useSearchParams() {
    return new URLSearchParams()
  },
  usePathname() {
    return '/'
  },
}))

// Mock environment variables
process.env.NEXT_PUBLIC_APP_URL = 'http://localhost:3000'
process.env.DATABASE_URL = ':memory:'

// Global test utilities
global.TextEncoder = TextEncoder
global.TextDecoder = TextDecoder
```

## ðŸ§ª **Unit Testing Patterns**

### Service Testing
```typescript
// UserService.test.ts
import { UserService } from './UserService'
import { UserRepository } from '../repositories/UserRepository'
import { ValidationError, NotFoundError } from '@/lib/errors'

// Mock the repository
jest.mock('../repositories/UserRepository')
const MockUserRepository = UserRepository as jest.MockedClass<typeof UserRepository>

describe('UserService', () => {
  let userService: UserService
  let mockRepository: jest.Mocked<UserRepository>

  beforeEach(() => {
    mockRepository = new MockUserRepository() as jest.Mocked<UserRepository>
    userService = new UserService(mockRepository)
    jest.clearAllMocks()
  })

  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      // Arrange
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
      }
      const expectedUser = {
        id: '1',
        ...userData,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }
      mockRepository.create.mockResolvedValue(expectedUser)

      // Act
      const result = await userService.createUser(userData)

      // Assert
      expect(result).toEqual(expectedUser)
      expect(mockRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          email: userData.email,
          name: userData.name,
          createdAt: expect.any(String),
          updatedAt: expect.any(String),
        })
      )
    })

    it('should throw ValidationError for invalid email', async () => {
      // Arrange
      const invalidData = {
        email: 'invalid-email',
        name: 'Test User',
      }

      // Act & Assert
      await expect(userService.createUser(invalidData))
        .rejects.toThrow(ValidationError)
      expect(mockRepository.create).not.toHaveBeenCalled()
    })

    it('should handle repository errors gracefully', async () => {
      // Arrange
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
      }
      mockRepository.create.mockRejectedValue(new Error('Database error'))

      // Act & Assert
      await expect(userService.createUser(userData))
        .rejects.toThrow('Failed to create user')
    })
  })

  describe('findUserById', () => {
    it('should return user when found', async () => {
      // Arrange
      const userId = '1'
      const expectedUser = {
        id: userId,
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }
      mockRepository.findById.mockResolvedValue(expectedUser)

      // Act
      const result = await userService.findUserById(userId)

      // Assert
      expect(result).toEqual(expectedUser)
      expect(mockRepository.findById).toHaveBeenCalledWith(userId)
    })

    it('should throw NotFoundError when user not found', async () => {
      // Arrange
      const userId = 'nonexistent'
      mockRepository.findById.mockResolvedValue(null)

      // Act & Assert
      await expect(userService.findUserById(userId))
        .rejects.toThrow(NotFoundError)
    })
  })
})
```

### Repository Testing
```typescript
// UserRepository.test.ts
import { UserRepository } from './UserRepository'
import { getDatabase } from '@/lib/db'

// Mock the database
jest.mock('@/lib/db', () => ({
  getDatabase: jest.fn(() => ({
    getKysely: jest.fn(() => ({
      selectFrom: jest.fn(() => ({
        selectAll: jest.fn(() => ({
          where: jest.fn(() => ({
            executeTakeFirst: jest.fn(),
            execute: jest.fn(),
          })),
          execute: jest.fn(),
          executeTakeFirst: jest.fn(),
        })),
      })),
      insertInto: jest.fn(() => ({
        values: jest.fn(() => ({
          returningAll: jest.fn(() => ({
            executeTakeFirst: jest.fn(),
          })),
        })),
      })),
      updateTable: jest.fn(() => ({
        set: jest.fn(() => ({
          where: jest.fn(() => ({
            executeTakeFirst: jest.fn(),
          })),
        })),
      })),
      deleteFrom: jest.fn(() => ({
        where: jest.fn(() => ({
          executeTakeFirst: jest.fn(),
        })),
      })),
    })),
  })),
}))

describe('UserRepository', () => {
  let repository: UserRepository
  let mockDb: any

  beforeEach(() => {
    mockDb = getDatabase()
    repository = new UserRepository(mockDb)
    jest.clearAllMocks()
  })

  describe('findByEmail', () => {
    it('should return user with matching email', async () => {
      // Arrange
      const email = 'test@example.com'
      const expectedUser = {
        id: '1',
        email,
        name: 'Test User',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }

      const mockQuery = {
        executeTakeFirst: jest.fn().mockResolvedValue(expectedUser),
      }
      mockDb.getKysely().selectFrom().selectAll().where.mockReturnValue(mockQuery)

      // Act
      const result = await repository.findByEmail(email)

      // Assert
      expect(result).toEqual(expectedUser)
      expect(mockQuery.executeTakeFirst).toHaveBeenCalled()
    })

    it('should return null when user not found', async () => {
      // Arrange
      const email = 'nonexistent@example.com'
      const mockQuery = {
        executeTakeFirst: jest.fn().mockResolvedValue(null),
      }
      mockDb.getKysely().selectFrom().selectAll().where.mockReturnValue(mockQuery)

      // Act
      const result = await repository.findByEmail(email)

      // Assert
      expect(result).toBeNull()
    })
  })
})
```

## ðŸŽ¨ **Component Testing**

### React Component Testing
```typescript
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { Button } from './Button'

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument()
  })

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled button</Button>)
    expect(screen.getByRole('button')).toBeDisabled()
  })

  it('applies correct variant classes', () => {
    render(<Button variant="danger">Danger button</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-red-600')
  })

  it('applies correct size classes', () => {
    render(<Button size="lg">Large button</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('px-6', 'py-3', 'text-lg')
  })
})
```

### Server Component Testing
```typescript
// UserList.test.tsx
import { render, screen } from '@testing-library/react'
import { UserList } from './UserList'

// Mock the database
jest.mock('@/lib/db', () => ({
  getRepository: jest.fn(() => ({
    findAll: jest.fn(),
  })),
}))

describe('UserList', () => {
  it('renders users from props', async () => {
    const mockUsers = [
      {
        id: '1',
        name: 'John Doe',
        email: 'john@example.com',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
      {
        id: '2',
        name: 'Jane Smith',
        email: 'jane@example.com',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
    ]

    render(<UserList initialUsers={mockUsers} />)

    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('jane@example.com')).toBeInTheDocument()
  })

  it('renders empty state when no users', () => {
    render(<UserList initialUsers={[]} />)
    expect(screen.getByText('No users found')).toBeInTheDocument()
  })
})
```

## ðŸŒ **API Testing**

### API Route Testing
```typescript
// app/api/users/route.test.ts
import { NextRequest } from 'next/server'
import { GET, POST } from './route'
import { auth } from '@/lib/auth'

// Mock authentication
jest.mock('@/lib/auth', () => ({
  auth: jest.fn(),
}))

// Mock database
jest.mock('@/lib/db', () => ({
  getRepository: jest.fn(() => ({
    findAll: jest.fn(),
    create: jest.fn(),
  })),
}))

describe('/api/users', () => {
  describe('GET', () => {
    it('should return users for authenticated user', async () => {
      // Arrange
      const mockUser = { id: '1', name: 'Test User' }
      ;(auth as jest.Mock).mockResolvedValue({ user: { id: '1' } })
      const mockRepo = { findAll: jest.fn().mockResolvedValue([mockUser]) }
      ;(require('@/lib/db').getRepository as jest.Mock).mockReturnValue(mockRepo)

      // Act
      const response = await GET()
      const data = await response.json()

      // Assert
      expect(response.status).toBe(200)
      expect(data).toEqual([mockUser])
    })

    it('should return 401 for unauthenticated user', async () => {
      // Arrange
      ;(auth as jest.Mock).mockResolvedValue(null)

      // Act
      const response = await GET()

      // Assert
      expect(response.status).toBe(401)
    })
  })

  describe('POST', () => {
    it('should create user with valid data', async () => {
      // Arrange
      const userData = { name: 'New User', email: 'new@example.com' }
      const createdUser = { id: '1', ...userData }
      
      ;(auth as jest.Mock).mockResolvedValue({ user: { id: '1' } })
      const mockRepo = { create: jest.fn().mockResolvedValue(createdUser) }
      ;(require('@/lib/db').getRepository as jest.Mock).mockReturnValue(mockRepo)

      const request = new NextRequest('http://localhost:3000/api/users', {
        method: 'POST',
        body: JSON.stringify(userData),
        headers: { 'Content-Type': 'application/json' },
      })

      // Act
      const response = await POST(request)
      const data = await response.json()

      // Assert
      expect(response.status).toBe(201)
      expect(data).toEqual(createdUser)
      expect(mockRepo.create).toHaveBeenCalledWith(userData)
    })
  })
})
```

## ðŸŽ­ **Mock Patterns**

### Database Mocking
```typescript
// src/__tests__/mocks/database.ts
export const createMockDatabase = () => ({
  getRepository: jest.fn((table: string) => ({
    findById: jest.fn(),
    findAll: jest.fn(),
    create: jest.fn(),
    update: jest.fn(),
    delete: jest.fn(),
    findBy: jest.fn(),
    count: jest.fn(),
    exists: jest.fn(),
  })),
  getKysely: jest.fn(() => ({
    selectFrom: jest.fn(() => ({
      selectAll: jest.fn(() => ({
        where: jest.fn(() => ({
          execute: jest.fn(),
          executeTakeFirst: jest.fn(),
        })),
        execute: jest.fn(),
        executeTakeFirst: jest.fn(),
      })),
    })),
    insertInto: jest.fn(() => ({
      values: jest.fn(() => ({
        returningAll: jest.fn(() => ({
          executeTakeFirst: jest.fn(),
        })),
      })),
    })),
    updateTable: jest.fn(() => ({
      set: jest.fn(() => ({
        where: jest.fn(() => ({
          executeTakeFirst: jest.fn(),
        })),
      })),
    })),
    deleteFrom: jest.fn(() => ({
      where: jest.fn(() => ({
        executeTakeFirst: jest.fn(),
      })),
    })),
    transaction: jest.fn(() => ({
      execute: jest.fn((callback) => callback(createMockDatabase().getKysely())),
    })),
  })),
})
```

### Authentication Mocking
```typescript
// src/__tests__/mocks/auth.ts
export const createMockSession = (overrides = {}) => ({
  user: {
    id: '1',
    email: 'test@example.com',
    name: 'Test User',
  },
  expires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
  ...overrides,
})

export const mockAuth = (session = createMockSession()) => {
  jest.mocked(auth).mockResolvedValue(session)
}
```

## ðŸ“Š **Test Data and Fixtures**

### Test Data Factory
```typescript
// src/__tests__/fixtures/user.ts
export const createUserFixture = (overrides = {}) => ({
  id: '1',
  email: 'test@example.com',
  name: 'Test User',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  ...overrides,
})

export const createUsersFixture = (count: number) => {
  return Array.from({ length: count }, (_, index) =>
    createUserFixture({
      id: String(index + 1),
      email: `user${index + 1}@example.com`,
      name: `User ${index + 1}`,
    })
  )
}
```

## ðŸŽ¯ **Quality Gates**

### Code Coverage Requirements
- **Unit Tests**: Minimum 80% coverage
- **Integration Tests**: Minimum 60% coverage
- **API Tests**: Minimum 90% coverage
- **Critical Paths**: 100% coverage required

### Performance Testing
```typescript
// Performance test example
describe('UserService Performance', () => {
  it('should handle 1000 concurrent requests', async () => {
    const startTime = Date.now()
    
    const promises = Array.from({ length: 1000 }, () =>
      userService.findAll()
    )
    
    await Promise.all(promises)
    
    const endTime = Date.now()
    const duration = endTime - startTime
    
    expect(duration).toBeLessThan(5000) // Should complete within 5 seconds
  })
})
```

### Accessibility Testing
```typescript
// Accessibility test example
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

describe('Button Accessibility', () => {
  it('should not have accessibility violations', async () => {
    const { container } = render(<Button>Accessible button</Button>)
    const results = await axe(container)
    expect(results).toHaveNoViolations()
  })
})
```

## ðŸš¨ **Error Testing**

### Error Boundary Testing
```typescript
// ErrorBoundary.test.tsx
import { render, screen } from '@testing-library/react'
import { ErrorBoundary } from './ErrorBoundary'

const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) {
    throw new Error('Test error')
  }
  return <div>No error</div>
}

describe('ErrorBoundary', () => {
  it('renders children when no error', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    )
    expect(screen.getByText('No error')).toBeInTheDocument()
  })

  it('renders error UI when error occurs', () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation()
    
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )
    
    expect(screen.getByText('Something went wrong')).toBeInTheDocument()
    consoleSpy.mockRestore()
  })
})
```

## ðŸ“ˆ **Continuous Integration**

### GitHub Actions Workflow
```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run type checking
        run: npm run type-check
      
      - name: Run linting
        run: npm run lint
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
```

## ðŸŽ¯ **Quality Checklist**

### Before Submitting Code:
- [ ] All tests pass
- [ ] Code coverage meets requirements
- [ ] No linting errors
- [ ] TypeScript compilation successful
- [ ] Performance tests pass
- [ ] Accessibility tests pass
- [ ] Error handling tested
- [ ] Edge cases covered
- [ ] Documentation updated

### Code Review Focus:
- **Test Coverage**: Adequate test coverage for new code
- **Test Quality**: Tests are meaningful and test behavior, not implementation
- **Error Handling**: Proper error handling and testing
- **Performance**: No performance regressions
- **Accessibility**: Components are accessible
- **Maintainability**: Tests are maintainable and clear

This quality standard ensures that all NOORMME code meets the highest standards of reliability, maintainability, and user experience while following the NORMIE DEV methodology.