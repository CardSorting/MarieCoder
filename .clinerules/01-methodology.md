# NORMIE DEV Methodology

## üéØ Core Philosophy

### "Does this spark joy?"
When building features, ask:
- Does this make developers happier?
- Does this reduce complexity?
- Does this improve the experience?
- Does this add value?

**If no, don't build it.**

### "Thank it for its service and let it go"
Acknowledge what taught us valuable lessons, then **DELETE IMMEDIATELY**:

- **Thank you, PostgreSQL complexity** ‚Üí **DELETED** - Now we use SQLite with WAL mode
- **Thank you, framework abstractions** ‚Üí **DELETED** - Now we use standard tools directly
- **Thank you, configuration hell** ‚Üí **DELETED** - Now we use smart defaults
- **Thank you, vendor lock-in** ‚Üí **DELETED** - Now we use framework-agnostic patterns
- **Thank you, legacy services** ‚Üí **DELETED** - Now we use unified architecture
- **Thank you, backward compatibility** ‚Üí **DELETED** - Now we use clean breaks only

### "Keep only what sparks joy"
Preserve what makes development delightful:
- ‚úÖ **SQLite simplicity** with PostgreSQL-like capabilities
- ‚úÖ **Next.js performance** with proven organizational patterns
- ‚úÖ **TypeScript safety** with auto-generated types
- ‚úÖ **Zero configuration** with intelligent defaults

## üèóÔ∏è Implementation Guidelines

### Eliminate Complexity - ZERO TOLERANCE
- **DELETE** unnecessary abstractions immediately
- **DELETE** complex configuration - use smart defaults only
- **DELETE** boilerplate - use automation instead
- **DELETE** learning curves - use proven patterns only

### Preserve Value
- Keep powerful features
- Maintain performance
- Ensure type safety
- Provide excellent DX

### Organize What Remains
- Apply proven patterns
- Use consistent conventions
- Create clear structure
- Maintain flexibility

## üéØ Decision Framework

### For Every Feature - MANDATORY QUESTIONS
1. **Does this spark joy?** (Improves developer experience)
2. **Can we DELETE legacy code?** (Eliminate old implementations)
3. **Does this add value?** (Solve real problems)
4. **Can we compose this?** (Use existing tools)

### For Every Abstraction - ELIMINATION CHECKLIST
1. **Is this necessary?** (Does it solve a real problem)
2. **Can we DELETE this?** (Use existing tools instead)
3. **Does this improve DX?** (Better developer experience)
4. **Can we DELETE complexity?** (Reduce cognitive load to zero)

## üö® Legacy Elimination Protocol

### MANDATORY Actions:
1. **DELETE** all legacy files immediately
2. **DELETE** backward compatibility layers
3. **DELETE** old service implementations
4. **DELETE** complex abstractions
5. **REPLACE** with clean, unified architecture

### FORBIDDEN Actions:
- ‚ùå Maintaining legacy code "for compatibility"
- ‚ùå Creating wrapper services
- ‚ùå Gradual migration strategies
- ‚ùå Keeping old and new systems simultaneously

**Remember**: Software development should spark joy, not frustration. **DELETE everything that doesn't spark joy.**
